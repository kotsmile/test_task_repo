## Тестовая задача: базовая реализация рекомендательной системы

Требуется реализовать в виде класса рекомендательную систему,
формирующую рекомендации по просмотрам фильмов для пользователей
только на основании прошлых пользовательских оценок,
основанную на SVD разложении матрицы рейтингов пользователей. 

#### Атрибуты класса `recommend_system`: 

- `k` - параметр SVD разложения (указывается и сохраняется при инициализации 
объекта класса),
- `users_embeddings`, `items_embeddings` – списки, словари либо матрицы 
(выбрать структуру) k-мерных профилей пользователей и фильмов, 
полученные в результате SVD разложения матрицы рейтингов 
(вычисляются и сохраняются в методе fit; 
профилем пользователя/итема мы называем некоторый k-мерный вектор), 
- `ranking_model` – объект модели, выполняющей ранжирование фильмов для пользователей 
(создаётся, обучается и сохраняется в методе fit). 

При необходимости можно создавать и другие атрибуты.

#### Методы класса `recommend_system`: 

`fit(list users, list items, list ratings)`

Пусть U - количество пользователей, I - количество фильмов. В этом методе требуется:

- Создать матрицу рейтингов размера U x I,
- Выполнить ее SVD разложение и получить матрицы профилей юзеров (размера U x k) и итемов (размера k x I),
сохранить эти профили в качестве атрибутов в виде выбранной структуры,
- Выбрать регрессор, который будет выполнять ранжирование,
- Обучить этот регрессор на множестве данных ((юзер, итем): рейтинг)
(модель принимает вектор длины 2k – профиль юзера и профиль фильма,
и обучается на одно число – рейтинг этой пары), сохранить регрессор в качестве атрибута.

`predict(list users, list items)`

В этом методе требуется для каждой пары (юзер, итем)
взять их профили и подать в обученный регрессор.
Метод должен возвращать предсказанный list рейтингов.

`recommend(int user_id, int N)`

Данный метод должен формировать рекомендации для юзера `user_id`:

- Взять все итемы, которые раньше не видел этот юзер,
- Спрогнозировать оценки этим итемам от этого юзера методом `predict`,
- Взять топ N итемов по полученным оценкам и упорядочить их по убыванию 
оценок. Метод должен возвращать этот список.

#### Использование рекомендательной системы: запускаемые файлы

При запуске программы `main1.py` создается объект рек-системы,
обучается на данных `ratings_train.csv` и сохраняется на диске с помощью pickle.

При запуске программы `main2.py` с помощью pickle открывается 
сохраненный ранее объект обученной рек-системы,
выполняется прогноз рейтингов для юзеров/итемов из файла `ratings_test.csv`
и вычисляется средняя абсолютная ошибка (mae) предсказанных рейтингов.
Аналогично вычислить mae на данных `ratings_train.csv` (дальше в той же программе).
Протестировать 3 различных регрессора (заменяя их в методе `fit`), и их конфигурации.

При запуске программы `main3.py` выводятся рекомендации фильмов для заданного юзера и числа N.

#### Язык разработки:
python 3.6+.

#### Полезные запросы в google: 
- Python regressors
- Python svd
- Python pickle

#### Ссылки для чтения:

https://ru.wikipedia.org/wiki/Сингулярное_разложение (о параметре k,
определяющем размерность профилей, смотри в разделе 'Сокращенное представление')

Понятие и типы рекомендательных систем:

http://www.machinelearning.ru/wiki/images/9/95/Voron-ML-CF.pdf

https://logic.pdmi.ras.ru/~sergey/teaching/mlstc12/15-recommender.pdf

https://towardsdatascience.com/the-4-recommendation-engines-that-can-predict-your-movie-tastes-109dc4e10c52 

Примеры разных рекомендательных систем:

https://towardsdatascience.com/creating-a-movie-recommender-using-convolutional-neural-networks-be93e66464a7

https://towardsdatascience.com/my-journey-to-building-book-recommendation-system-5ec959c41847

